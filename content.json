{"pages":[{"title":"About","text":"Todo","link":"/about/index.html"},{"title":"","text":"{\"TableName\":\"pies\",\"KeySchema\":[{\"AttributeName\":\"id\",\"KeyType\":\"HASH\"},{\"AttributeName\":\"name\",\"KeyType\":\"RANGE\"}],\"AttributeDefinitions\":[{\"AttributeName\":\"id\",\"AttributeType\":\"N\"},{\"AttributeName\":\"name\",\"AttributeType\":\"S\"}],\"ProvisionedThroughput\":{\"ReadCapacityUnits\":1,\"WriteCapacityUnits\":1}}","link":"/downloads/dynamo-db/create-table-pies.json"},{"title":"","text":"{\"pies\":[{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"1\"},\"name\":{\"S\":\"Bacon and egg pie\"},\"taste\":{\"S\":\"savoury\"},\"main_ingredient\":{\"S\":\"bacon\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"2\"},\"name\":{\"S\":\"Scotch pie\"},\"taste\":{\"S\":\"savoury\"},\"main_ingredient\":{\"S\":\"minced meat\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"3\"},\"name\":{\"S\":\"Pork pie\"},\"taste\":{\"S\":\"savoury\"},\"main_ingredient\":{\"S\":\"pork\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"4\"},\"name\":{\"S\":\"Steak pie\"},\"taste\":{\"S\":\"savoury\"},\"main_ingredient\":{\"S\":\"steak\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"5\"},\"name\":{\"S\":\"Kurnik\"},\"taste\":{\"S\":\"savoury\"},\"main_ingredient\":{\"S\":\"chicken\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"6\"},\"name\":{\"S\":\"Fisherman's pie\"},\"taste\":{\"S\":\"savoury\"},\"main_ingredient\":{\"S\":\"white fish\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"7\"},\"name\":{\"S\":\"Apple pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"apple\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"8\"},\"name\":{\"S\":\"Blackberry pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"blackberry\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"9\"},\"name\":{\"S\":\"Blueberry pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"blueberry\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"10\"},\"name\":{\"S\":\"Cherry pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"cherry\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"11\"},\"name\":{\"S\":\"Banana cream pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"banana\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"12\"},\"name\":{\"S\":\"Lemon meringue pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"lemon\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"13\"},\"name\":{\"S\":\"Bundevara\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"pumpkin\"}}}},{\"PutRequest\":{\"Item\":{\"id\":{\"N\":\"14\"},\"name\":{\"S\":\"Strawberry cheese pie\"},\"taste\":{\"S\":\"sweet\"},\"main_ingredient\":{\"S\":\"strawberry\"}}}}]}","link":"/downloads/dynamo-db/load-data-pies.json"}],"posts":[{"title":"DynamoDB Pagination Tale Or Expect The Unexpected","text":"You have lots of pies - 6 savour and 8 sweet. You take all the sweet pies you can get from the query above. How many do you have?What happens when you try to filter data in DynamoDB?Can you guess the answer already?IntroLooking at the query the most obvious answer comes to mind. It should be 2 pies. Query sets a limit of two so that’s what you have.Well… Might be, might not be. limit might not be what you think it is. And the answer lies in how DynamoDB API implements it’s interface.We will take a look on how to make our data queries more predictable.Data SetFirst of all we need a table and some data in it.To create a table we need to specify a primary key. It can either consist of a partition key or both a partition key and a sort key. We will go with the latter option:id – As partition key of type number.name – As sort key of type string.And here they are as as parameters for the create-table command:create-table-pies.jsonView on Github&#123; \"TableName\": \"pies\", \"KeySchema\": [ &#123; \"AttributeName\": \"id\", \"KeyType\": \"HASH\" &#125;, &#123; \"AttributeName\": \"name\", \"KeyType\": \"RANGE\" &#125; ], \"AttributeDefinitions\": [ &#123; \"AttributeName\": \"id\", \"AttributeType\": \"N\" &#125;, &#123; \"AttributeName\": \"name\", \"AttributeType\": \"S\" &#125; ], \"ProvisionedThroughput\": &#123; \"ReadCapacityUnits\": 1, \"WriteCapacityUnits\": 1 &#125;&#125;KeyShema attribute is our primary key definition, the AttributeDefinitions attribute is the types of our composite primary key and the last attribute ProvisionedThroughput is related to how much reads and writes DynamoDB will be processing per second. Reads and writes are set to minimal capacities because our dataset is rather small.Run this command to create the table:aws dynamodb create-table --cli-input-json file://create-table-pies.jsonLoading dataWe will batch load sample data as shown below where pies is the table name and PutRequest is the action we want to perform.Notice how the item attributes have to explicitly specify their types in DynamoDB fashion. E.g. id don't just have it's value set directly but with a type attribute: \"id\": { \"N\": \"1\" }.load-data-pies.jsonView on Github&#123; \"pies\": [ &#123; \"PutRequest\": &#123; \"Item\": &#123; \"id\": &#123; \"N\": \"1\" &#125;, \"name\": &#123; \"S\": \"Bacon and egg pie\" &#125;, \"taste\": &#123; \"S\": \"savoury\" &#125;, \"main_ingredient\": &#123; \"S\": \"bacon\" &#125; &#125; &#125; &#125;, &#123; \"PutRequest\": &#123; \"Item\": &#123; \"id\": &#123; \"N\": \"2\" &#125;, \"name\": &#123; \"S\": \"Scotch pie\" &#125;, \"taste\": &#123; \"S\": \"savoury\" &#125;, \"main_ingredient\": &#123; \"S\": \"minced meat\" &#125; &#125; &#125; &#125;, // truncated ]&#125;Execute batch-write-item to insert the data:aws dynamodb batch-write-item --request-items file://load-data-pies.jsonSimplified result:Let’s try filtering!DynamoDB defines two methods for data retrieval: scan and query. The essential difference between them is that scan reads every item in the table and query finds item(s) based on primary key values.However, that does not mean that the results of a scan operation can’t be further filtered out. DynamoDB provides a filter-expression for that matter:aws dynamodb scan \\ --table-name pies \\ --filter-expression \"taste = :taste\" \\ --expression-attribute-values '&#123;\":taste\":&#123;\"S\":\"sweet\"&#125;&#125;'In the filter-expression - the first part “taste” is the column name used for filtering and “:taste” is the filter value. The filter value has to be defined in the expression-attribute-values.When we run that command we get the expected results. Just the 8 sweet pies.However, suppose you are a pie magnate that has a storage of thousands and thousands of pies somewhere. Will you still get the data just the way you might expect?As your storage needs grow at some point you will face pagination. Pagination can be applied by you manually or you might hit one of the default AWS default limits which is 1MB result set per Scan operation call.DynamoDB limits are listed here1MB limit can be calculated based on record size.We can also set a pagination limit by ourselves via the --limit [number] on the AWS CLI command.Let’s try that out:aws dynamodb scan \\ --table-name pies \\ --limit 2 \\ --filter-expression \"taste = :taste\" \\ --expression-attribute-values '&#123;\":taste\":&#123;\"S\":\"sweet\"&#125;&#125;'It will produce an output like this:Scan with limit result&#123; \"Items\": [ &#123; \"name\": &#123; \"S\": \"Blueberry pie\" &#125;, \"id\": &#123; \"N\": \"9\" &#125;, \"main_ingredient\": &#123; \"S\": \"blueberry\" &#125;, \"taste\": &#123; \"S\": \"sweet\" &#125; &#125; ], \"Count\": 1, \"ScannedCount\": 2, \"LastEvaluatedKey\": &#123; \"name\": &#123; \"S\": \"Blueberry pie\" &#125;, \"id\": &#123; \"N\": \"9\" &#125; &#125;&#125;The Items section shows us what data DynamoDB has found when executing our query.Just 1 item! Not 2.If we take a closer look at these two fields we will get an idea of what happened:\"Count\": 1\"ScannedCount\": 2Count is how many items were left after filter was applied and that is what we see in the final result.ScannedCount, on the other hand, means how many items were scanned. It’s value is 2 just like our limit value.DynamoDB applies it's limits first and only THEN filters out the result!That poses a question on how to get the rest of the items if any limit is applied. As you can see above we get LastEvaluatedKey which is the key of our next item. We can use that as a starting position for executing our next scan request.Solving the problem…Manually:aws dynamodb scan \\ --table-name pies \\ --limit 2 \\ --filter-expression \"taste = :taste\" \\ --expression-attribute-values '&#123;\":taste\":&#123;\"S\":\"sweet\"&#125;&#125;' \\ --exclusive-start-key '&#123;\"name\": &#123;\"S\": \"Blueberry pie\"&#125;, \"id\": &#123;\"N\": \"9\"&#125;&#125;'… And repeat until we go through all the items in the database.Programmatically (NodeJS) it would look like this:revised-solution.js1234567891011121314151617181920212223// Params to pass to DynamoDB scanconst sweetPiesFilter = &#123; ExpressionAttributeValues: &#123; ':taste': &#123; S: 'sweet' &#125; &#125;, FilterExpression: 'taste = :taste', TableName: 'pies'&#125;async scan(params, resultSet = []) &#123; const [Items, LastEvaluatedKey] = await db.scan(params).promise() const result = [...resultSet, ...Items] // If there are more items to fetch then we should do that if (LastEvaluatedKey) &#123; const updatedParams = Object.assign(&#123;&#125;, params, &#123; ExclusiveStartKey: LastEvaluatedKey &#125;) await read(updatedParams, result); &#125; return result&#125;const allSweetPies = await scan(sweetPiesFilter) // 8const onlyFiveSweetPiesFilter = Object.assign(&#123;&#125;, sweetPiesFilter, &#123; Limit: 5 &#125;)const onlyFiveSweetPies = await scan(onlyFiveSweetPiesFilter) // Still 8!However, there’s a problem with this script.Suppose we actually need to limit our data to a certain pagination limit precisely. Say 10.Loop until you get 10 items if they are present and then break out of the loop.Revised solutionrevised-solution.js123456789101112131415161718192021222324252627// Params to pass to DynamoDB scanconst sweetPiesFilter = &#123; ExpressionAttributeValues: &#123; ':taste': &#123; S: 'sweet' &#125; &#125;, FilterExpression: 'taste = :taste', TableName: 'pies'&#125;async scan(params, enforcedLimit, resultSet = []) &#123; const [Items, LastEvaluatedKey] = await db.scan(params).promise() const result = [...resultSet, ...Items] // Determine if we need to fetch more items const noEnforcedLimit = !enforcedLimit const enforcedLimitNotReached = enforcedLimit &amp;&amp; result.length &lt; enforcedLimit const shouldGetMoreItems = LastEvaluatedKey &amp;&amp; noEnforcedLimit &amp;&amp; enforcedLimitNotReached if (shouldGetMoreItems) &#123; const updatedParams = Object.assign(&#123;&#125;, params, &#123; ExclusiveStartKey: scanResult.LastEvaluatedKey &#125;) await read(updatedParams, [...resultSet, ...scanResult.Items]); &#125; // Discard items if there are more than we want return enforcedLimit ? result.slice(0, enforcedLimit) : result&#125;const onlyFiveSweetPies = await scan(sweetPiesFilter, 5) // 5const onlyTenSweetPies = await scan(sweetPiesFilter, 10) // 8. That's all there isBingo!TakeawaysBe careful about your assumptions on command’s parameter names and read the official documentation carefully.Also, try out the code above :)","link":"/2018/12/08/dynamodb-pagination-tale-or-expect-the-unexpected/"}],"tags":[{"name":"dynamodb","slug":"dynamodb","link":"/tags/dynamodb/"},{"name":"aws","slug":"aws","link":"/tags/aws/"}],"categories":[{"name":"AWS","slug":"aws","link":"/categories/aws/"}]}